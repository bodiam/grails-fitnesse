<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>1.1 Features</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    The Fitnesse plugin supports some additional features besides the standard Fitnesse functionality.<p class="paragraph"/>
<h3>Support for GivWenZen (since 1.0)</h3><p class="paragraph"/>Since version 1.0, we support the <a href="http://code.google.com/p/givwenzen/" target="blank">GivWenZen</a> library. GivWenZen allows a user to use the BDD Given When Then vocabulary and plain text sentences to help a team get the words right and create a ubiquitous language to describe and test a business domain. See the <a href="http://code.google.com/p/givwenzen/" target="blank">GivWenZen</a> website for more information.<p class="paragraph"/>To use GivWenZen in Grails Fitnesse, import the <code>fitnesse.grails</code> package and use the <code>GivWenZenForGrails</code> fixture in a script table, as can be seen in the example below:<p class="paragraph"/><div class="code"><pre>|<span class="java&#45;keyword">import</span>|
|fitnesse.grails|<p class="paragraph"/>|script|
|start|giv wen zen <span class="java&#45;keyword">for</span> grails|<p class="paragraph"/>|script|
|given|the number 5|
|when|incrementing it by 3|
|then|the result is 8|<p class="paragraph"/>|script|
|given|the number 1|
|when|incrementing it by 2|
|and|incrementing it by 3|
|then|the result is 6|</pre></div><p class="paragraph"/>To make this test work, you'll need a step class like the one below:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.givwenzen.annotations.DomainStep
<span class="java&#45;keyword">import</span> org.givwenzen.annotations.DomainSteps<p class="paragraph"/>@DomainSteps
class GivWenZenSupportSteps &#123;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">int</span> number<p class="paragraph"/>	@DomainStep("the number (&#92;&#92;d+)<span class="java&#45;quote">")
	void setNumber(<span class="java&#45;object">int</span> number) &#123;
		<span class="java&#45;keyword">this</span>.number = number
	&#125;<p class="paragraph"/>	@DomainStep("</span>incrementing it by (&#92;&#92;d+)<span class="java&#45;quote">")
	void incrementNumber(<span class="java&#45;object">int</span> by) &#123;
		number += by
	&#125;<p class="paragraph"/>	@DomainStep("</span>the result is (&#92;&#92;d+)")
	<span class="java&#45;object">boolean</span> expect(<span class="java&#45;object">int</span> result) &#123;
		number == result
	&#125;
&#125;</pre></div><p class="paragraph"/><h3>Automatic Enum mapping (since 0.95)</h3><p class="paragraph"/>Since version 0.95, it's possible to automatically map enum values. Just specify the value of the enum in the table, and you're done.<p class="paragraph"/>An example:
<div class="code"><pre>class MyEnumFixture &#123;
    Color color
&#125;<p class="paragraph"/>enum Color &#123; RED, GREEN, BLUE &#125;</pre></div><p class="paragraph"/>By specifying the name of the enum value in the test (see below), the mapping is automatically done:<p class="paragraph"/><div class="code"><pre>|my enum     |
|color|color?|
|RED  |RED   |</pre></div><p class="paragraph"/><h3>Nested property mapping for Query Fixtures (since 0.95)</h3><p class="paragraph"/>It was already possible (since version 0.4) to create a simple Query Fixture using the Query Fixture DSL. This DSL has been extended by also allowing nested properties using a dotted (.) notation, as can be seen below:<p class="paragraph"/><div class="code"><pre>class NestedPropertyKeyValueQueryFixture &#123;
    <span class="java&#45;keyword">static</span> queryFixture = <span class="java&#45;keyword">true</span><p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#91;<span class="java&#45;quote">"name"</span>:<span class="java&#45;quote">"author.name"</span>, <span class="java&#45;quote">"birthYear"</span>:<span class="java&#45;quote">"author.birthYear"</span>, <span class="java&#45;quote">"title"</span>:<span class="java&#45;quote">"title"</span>&#93;<p class="paragraph"/>    def queryResults() &#123;
        <span class="java&#45;keyword">return</span> &#91;<span class="java&#45;keyword">new</span> Book(title:'Grails in Action', author: <span class="java&#45;keyword">new</span> Author(name:<span class="java&#45;quote">"Peter Ledbrook"</span>, birthYear: 1980))&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/>
<h3>Fixture annotation (since 0.9)</h3><p class="paragraph"/>Since version 0.9, it's possible to annotate Fixture classes with the @Fixture annotatation.
This means that fixtures can now be given any name (ie. they don't have to be suffixed with Fixture), as long as they are annotated with the @Fixture annotation.<p class="paragraph"/><div class="code"><pre>@Fixture
class BuyBook &#123;
    // contents here
&#125;</pre></div><p class="paragraph"/><h3>Transaction support (since 0.9)</h3><p class="paragraph"/>Transaction support provides three fixtures called BeginTransaction, Commit and Rollback. To use you need to import the fitnesse.grails package, i.e. in SetUp or SuiteSetUp:<p class="paragraph"/><div class="code"><pre>|<span class="java&#45;keyword">import</span>|
|fitnesse.grails|</pre></div><p class="paragraph"/>The transaction support was introduced mainly for scenarios where test pages via fixtures modify the database and you don't want that modifications to be persisted after the end of the test page execution. It means that the test page can be run multiple times without the need of cleaning up the database afterwards and it doesn't affect other tests by database contamination. To run a test page within a rolledback transaction simply add <code>begin transaction</code> and <code>rollback</code> tables to your test page:<p class="paragraph"/><div class="code"><pre>|begin transaction|<p class="paragraph"/>&#45;&#45;some test tables&#45;&#45;<p class="paragraph"/>|rollback|</pre></div><p class="paragraph"/>If you wish to run all of your test pages contained within a suite in rolledback transactions simply add begin transaction and rollback tables to SetUp and TearDown pages respectively for the given suite.<p class="paragraph"/><h3>Templates (since 0.4)</h3><p class="paragraph"/>You can now easily create Fixtures by typing:<p class="paragraph"/><div class="code"><pre>grails create&#45;fitnesse&#45;query&#45;fixture &#60;name of fixture&#62;</pre></div><p class="paragraph"/>Or<p class="paragraph"/><div class="code"><pre>grails create&#45;fitnesse&#45;fixture &#60;name of fixture&#62;</pre></div><p class="paragraph"/>This will create a fixture in the grails-app&#102;itnesse directory, which should give you a head start on how to create a Fixture.<p class="paragraph"/><h3>Complex objects (since 0.4)</h3><p class="paragraph"/>You can now create complex objects from within Fitnesse. This uses the JSON format, since it's easy to read and write, and is becoming quite a standard.<p class="paragraph"/>An example can be seen below:<p class="paragraph"/><strong class="bold">Wiki</strong>
<div class="code"><pre>|create book inventory                     |
|book                               |amount|
|&#123;author: Stephen King, title: IT&#125;  |     3|
|&#123;author: Dean Koontz, title: Chase&#125;|     5|</pre></div><p class="paragraph"/>This JSON code in the test is mapped to the following Fixture and Domain class:<p class="paragraph"/><strong class="bold">Fixture</strong>
<div class="code"><pre>class CreateBookInventoryFixture &#123;
    Book book<p class="paragraph"/>    <span class="java&#45;object">int</span> amount<p class="paragraph"/>    def bookService<p class="paragraph"/>    CreateBookInventoryFixture() &#123;
        Book.list()&#42;.delete()
    &#125;<p class="paragraph"/>    void execute() &#123;
        amount.times &#123;
            book.id = <span class="java&#45;keyword">null</span>
            bookService.addBook(book)
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>And the very simple Domain class:<p class="paragraph"/><div class="code"><pre>class Book &#123;
    <span class="java&#45;object">String</span> author
    <span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>Version 0.9 brings support for collections into JSON object conversion. The feature works for typed collection fixture fields but not for function parameters (because information about generics is is kept at runtime only for fields). It also works for hasMany relations in grails domain objects. Example usage is:<p class="paragraph"/><strong class="bold">Wiki</strong>
<div class="code"><pre>|json objects conversion with collections|
|producer|models|match?|
|&#123;name: 'Audi', models: &#91;&#123;name: 'A3'&#125;, &#123;name: 'A4'&#125;&#93;&#125;|&#91;&#123;name: 'A3'&#125;, &#123;name: 'A4'&#125;&#93;|<span class="java&#45;keyword">true</span>|</pre></div><p class="paragraph"/><strong class="bold">Fixture</strong>
<div class="code"><pre>class JsonObjectsConversionWithCollectionsFixture &#123;
    CarProducer producer<p class="paragraph"/>    List&#60;CarModel&#62; models<p class="paragraph"/>    <span class="java&#45;object">boolean</span> match() &#123;
        producer.models&#42;.name.containsAll(models&#42;.name)
    &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Domain classes</strong>
<div class="code"><pre>class CarProducer &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> hasMany = &#91;models: CarModel&#93;
&#125;<p class="paragraph"/>class CarModel &#123;
    <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/><h3>Query Fixture DSL (since 0.4)</h3><p class="paragraph"/>To make writing Query fixtures much easier, we've introduced the concept of a simple mapping DSL. This means that mapping values from, let's say a services, becomes almost trivial.<p class="paragraph"/>Consider the following Service method:<p class="paragraph"/><div class="code"><pre>def checkInventory() &#123;
    Book.executeQuery(<span class="java&#45;quote">"select b.title, b.author, count(&#42;) from Book b group by title, author"</span>)
&#125;</pre></div><p class="paragraph"/>If you want to use this method in a Fixture, you can do by using the mapping DSL. An example can be shown below. Note that this only works for Query fixtures!<p class="paragraph"/><div class="code"><pre>class CheckBookInventoryFixture &#123;
    <span class="java&#45;keyword">static</span> queryFixture = <span class="java&#45;keyword">true</span>                              // indication that <span class="java&#45;keyword">this</span> is a query fixture
    <span class="java&#45;keyword">static</span> mapping   = &#91;title: 0, author: 1, amount: 2&#93;  // the mapping<p class="paragraph"/>    def bookService        // injected service<p class="paragraph"/>    def queryResults() &#123;  // queryResults() method, which must be named like <span class="java&#45;keyword">this</span>!
        bookService.checkInventory()
    &#125;
&#125;</pre></div><p class="paragraph"/>The mapping property determines how the query results will be mapped before being sent back to FitNesse. The keys of the map are column names from the FitNesse query table for the given fixture. The values might be indexes of columns returned by the implementation of queryResults method (i.e. if they are results from a executeQuery) or property names (i.e. if queryResults returns a collection of domain objects). The mapping property can also be a list of property names if property names of the result map one to one to table column names. An example can be found below:<p class="paragraph"/><div class="code"><pre>class BookService &#123;
     List&#60;Book&#62; checkInventory() &#123;
        <span class="java&#45;keyword">return</span> Book.list()
     &#125;
&#125;<p class="paragraph"/>class CheckBookInventoryFixture &#123;
    <span class="java&#45;keyword">static</span> queryFixture = <span class="java&#45;keyword">true</span>                              // indication that <span class="java&#45;keyword">this</span> is a query fixture
    <span class="java&#45;keyword">static</span> mapping = &#91;<span class="java&#45;quote">"title"</span>, <span class="java&#45;quote">"author"</span>, <span class="java&#45;quote">"amount"</span>&#93;        // a different mapping<p class="paragraph"/>    def bookService        // injected service<p class="paragraph"/>    def queryResults() &#123;  // queryResults() method, which must be named like <span class="java&#45;keyword">this</span>!
        bookService.checkInventory()
    &#125;
&#125;</pre></div><p class="paragraph"/>or:<p class="paragraph"/>class CheckBookInventoryFixture {
    static queryFixture = true                              // indication that this is a query fixture
    static mapping = <a href=""objectTitle",">title</a> <a href=""theAuthor",">author</a> <a href=""amount"">amount</a> // a different mapping, where the key is the name of the test, and the value the property name of the object<p class="paragraph"/>    def bookService        // injected service<p class="paragraph"/>    def queryResults() {  // queryResults() method, which must be named like this!
        bookService.checkInventory()
    }
}<p class="paragraph"/><p class="paragraph"/>Since 0.9 you have to declare both queryFixture and mapping properties as static. It wasn't necessary before but the behaviour wasn't always consistent thus the support for non static properties was dropped.<p class="paragraph"/><h3>Strings as methods</h3>
Groovy supports methods like <code>"this is a method"</code>. The Fitnesse plugin also supports this, making some Fixtures more readable.<p class="paragraph"/><strong class="bold">Example</strong>
<div class="code"><pre>class MyFixture &#123;
  <span class="java&#45;object">boolean</span> <span class="java&#45;quote">"check <span class="java&#45;keyword">if</span> customers exists"</span>(<span class="java&#45;object">int</span> customerNumber) &#123;
     // &#8230;
  &#125;
&#125;</pre></div><p class="paragraph"/><h4>Default arguments</h4>
Groovy supports default arguments. The Grails Fitnesse plugin also supports this:<p class="paragraph"/><div class="code"><pre>class MyFixture &#123;
  MyFixture(<span class="java&#45;object">boolean</span> clearDatabase = <span class="java&#45;keyword">false</span>) &#123;
    // &#8230;
  &#125;
&#125;</pre></div><p class="paragraph"/><strong class="bold">Wiki:</strong>
<div class="code"><pre>|my fixture|<span class="java&#45;keyword">true</span>|</pre></div><p class="paragraph"/><h3>Untyped arguments</h3>
Groovy supports untyped method arguments. The Grails Fitnesse plugin also supports this:<p class="paragraph"/><div class="code"><pre>class MyFixture &#123;
  <span class="java&#45;object">boolean</span> checkCustomer(customerNumber) &#123;
    // &#8230;
  &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Note that the Fitnesse SLIM protocol only supports Strings and Lists. A result of this, is that when using untyped arguments, things could go wrong. An example of this is when using an integer.
This integer is interpreted as being a String, and hence it's converted to it's value, so int 1 becomes int 49. So, if you're unsure, use types in your fixtures.
</blockquote><p class="paragraph"/><h3>Automatic reloading of Fixtures</h3>
The Fixtures in the <code>grails-app/fitnesse</code> directory are automatically reloaded and injected by Grails. This enables faster testing and faster development!<p class="paragraph"/><h3>Functions are getters</h3>
Fitnesse decision tables do <strong class="bold">not</strong> have getters and setters, but setters and functions. A function is the same as a getter, but without the 'get' part. (Still with me?). An example:<p class="paragraph"/><strong class="bold">Normal Fitnesse</strong>
<div class="code"><pre>|my decision fixture|
|digit | roman?|
|1     |      I|
|5     |      V|</pre></div><p class="paragraph"/>This would result in the following Fixture:
<div class="code"><pre>class MyDecisionFixture &#123;
    <span class="java&#45;object">int</span> digit
    <span class="java&#45;object">String</span> roman<p class="paragraph"/>    void execute() &#123;
       roman = RomanNumberConverter.convertDigit(digit)
    &#125;<p class="paragraph"/>    <span class="java&#45;object">String</span> roman() &#123;
       <span class="java&#45;keyword">return</span> roman
    &#125;
&#125;</pre></div><p class="paragraph"/>This has been improved, so that Fitnesse also looks at getters:<p class="paragraph"/><strong class="bold">Improved Fitnesse</strong><p class="paragraph"/>This would result in the following Fixture:
<div class="code"><pre>class MyDecisionFixture &#123;
    <span class="java&#45;object">int</span> digit
    <span class="java&#45;object">String</span> roman<p class="paragraph"/>    void execute() &#123;
       roman = RomanNumberConverter.convertDigit(digit)
    &#125;
&#125;</pre></div><p class="paragraph"/><h3>Improved Stop Test Exceptions</h3><p class="paragraph"/>You can now throw <a href="http://fitnesse.org/FitNesse.UserGuide.SliM.ExceptionHandling" target="blank">StopTest Exceptions</a> from Fixture constructors, to halt all further test execution.
This is currently not handled correctly in the Java version of Fitnesse.
    </body>
</html>
