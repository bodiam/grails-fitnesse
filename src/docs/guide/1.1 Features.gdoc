The Fitnesse plugin supports some additional features besides the standard Fitnesse functionality.

h3. Templates (since 0.4)

You can now easily create Fixtures by typing:

{code}
grails create-fitnesse-query-fixture <name of fixture>
{code}

Or

{code}
grails create-fitnesse-fixture <name of fixture>
{code}

This will create a fixture in the grails-app\fitnesse directory, which should give you a head start on how to create a Fixture.

h3. Complex objects (since 0.4)

You can now create complex objects from within Fitnesse. This uses the JSON format, since it's easy to read and write, and is becoming quite a standard.

An example can be seen below:

*Wiki*
{code}
|create book inventory                     |
|book                               |amount|
|{author: Stephen King, title: IT}  |     3|
|{author: Dean Koontz, title: Chase}|     5|
{code}

This JSON code in the test is mapped to the following Fixture and Domain class:

*Fixture*
{code}
class CreateBookInventoryFixture {
    Book book

    int amount

    def bookService

    CreateBookInventoryFixture() {
        Book.list()*.delete()
    }

    void execute() {
        amount.times {
            book.id = null
            bookService.addBook(book)
        }
    }
}
{code}

And the very simple Domain class:

{code}
class Book {
    String author
    String title
}
{code}

h3. Query Fixture DSL (since 0.4)

To make writing Query fixtures much easier, we've introduced the concept of a simple mapping DSL. This means that mapping values from, let's say a services, becomes almost trivial.

Consider the following Service method:

{code}
def checkInventory() {
    Book.executeQuery("select b.title, b.author, count(*) from Book b group by title, author")
}
{code}

If you want to use this method in a Fixture, you can do by using the mapping DSL. An example can be shown below. Note that this only works for Query fixtures!

{code}
class CheckBookInventoryFixture {
    def queryFixture = true                              // indication that this is a query fixture
    static mapping   = [title: 0, author: 1, amount: 2]  // the mapping

    def bookService        // injected service

    def queryResults() {  // queryResults() method, which must be named like this!
        bookService.checkInventory()
    }
}
{code}

h3. Strings as methods
Groovy supports methods like @"this is a method"@. The Fitnesse plugin also supports this, making some Fixtures more readable.

*Example*
{code}
class MyFixture {
  boolean "check if customers exists"(int customerNumber) {
     // ...
  }
}
{code}

h4. Default arguments
Groovy supports default arguments. The Grails Fitnesse plugin also supports this:

{code}
class MyFixture {
  MyFixture(boolean clearDatabase = false) {
    // ...
  }
}
{code}

*Wiki:*
{code}
|my fixture|true|
{code}

h3. Untyped arguments
Groovy supports default arguments. Fitnesse also supports this:

{code}
class MyFixture {
  boolean checkCustomer(customerNumber) {
    // ...
  }
}
{code}

{note}
Note that the Fitnesse SLIM protocol only supports Strings and Lists. A result of this, is that when using untyped arguments, things could go wrong. An example of this is when using an integer.
This integer is interpreted as being a String, and hence it's converted to it's value, so int 1 becomes int 49. So, if you're unsure, use types in your fixtures.
{note}

h3. Automatic reloading of Fixtures
The Fixtures in the @grails-app/fitnesse@ directory are automatically reloaded and injected by Grails. This enables faster testing and faster development!

h3. Functions are getters
Fitnesse decision tables do *not* have getters and setters, but setters and functions. A function is the same as a getter, but without the 'get' part. (Still with me?). An example:

*Normal Fitnesse*
{code}
|my decision fixture|
|digit | roman?|
|1     |      I|
|5     |      V|
{code}

This would result in the following Fixture:
{code}
class MyDecisionFixture {
    int digit
    String roman

    void execute() {
       roman = RomanNumberConverter.convertDigit(digit)
    }

    String roman() {
       return roman
    }
}
{code}

This has been improved, so that Fitnesse also looks at getters:

*Improved Fitnesse*

This would result in the following Fixture:
{code}
class MyDecisionFixture {
    int digit
    String roman

    void execute() {
       roman = RomanNumberConverter.convertDigit(digit)
    }
}
{code}

h3. Improved Stop Test Exceptions

You can now throw [StopTest Exceptions|http://fitnesse.org/FitNesse.UserGuide.SliM.ExceptionHandling] from Fixture constructors, to halt all further test execution.
This is currently not handled correctly in the Java version of Fitnesse.